# iFunny

https://funcodechallenge.com/

## Преамбула

// TODO

## Сборка приложения

Для того, чтобы собрать приложение, необходимо иметь предустановленную JDK ≥ 8 и выполнить следующую команду:

```
$ ./gradlew assemble
```

### Сборка с тестами

Дело в том, что тесты, требующие БД производятся против реального сервера БД. 
На мой личный взгляд это один (или самый) из самых надежных способов тестирования. 

Сложность заключается лишь в развёртывании необходимого окружения. 
В случае с CI/CD GitLab Pipeline настроен таким образом, что перед сборкой поднимаются нужные сервисы и линкуются 
с тестируемым образом.

Для того, чтобы локально добиться того же результата, был создан `docker-compose.yml` файл.  

Итак, для сборки приложения с запуском всех тестов локально необходимо выполнить две команды:

```
$ docker-compose up -d
$ ./gradlew build
```

## Сборка Docker образа

Прежде, чем приступить к сборке Docker образа необходимо собрать само приложение. 
Необходимые шаги подробно описаны в соответстующем разделе.

Как только приложение создано, сборка Docker образа становится триаивльной задачей:

```
$ docker build -t ifunny .
```

## Запуск

### Переменные окружения

#### MongoDB

* `MONGODB_HOST` – Хост сервера MongoDB (По умолчанию `localhost`).
* `MONGODB_PORT` – Порт сервера MongoDB (По умолчанию `27017`)
* `MONGODB_DATABASE` - Имя базы данных MongoDB (По умолчанию `ifunny`).
* `MONGODB_USERNAME` – Имя пользователя MongoDB (По умолчанию `ifunny`).
* `MONGODB_PASSWORD` – Пароль пользователя MongoDB (По умолчанию `ifunny`).
* `MONGODB_AUTH_DB` – База данных аутентификации MongoDB (По умолчанию `admin`).

### Локальное окружение

Для удобства развертывания локального окружения (в целях разработки) в корневом каталоге расположен `docker-compose.yml`.

#### Запуск через терминал

```
$ docker-compose up -d
```

#### Запуск через IDEA

Если Вы используете Intellij IDEA, в репозиторий добавлена конфигурация запуска Docker-compose под именем `Local Environment`.

## Реализация

### Версионирование

// TODO

### Источники

Источник – веб-сайт с мемами, который является предметом для парсинга и обработки приложением. 

Архитектура основана на предположении, что каждый источник возвращает ленту, разделенную на страницы (Pagination).

В объектной модели источник представляет класс `Channel` (канал). 
Для добавления нового источника разработчику необходимо добавить новый бин класса `Channel`, 
реализовав абстрактные методы: `pagePath`, `parsePage`, `parseMeme`.
Изначально была идея реализовать Kotlin DSL, позволяющий как-то простенько конфигурировать новые источники 
и даже иметь Hot-Reload этих источников, но на деле оказалось, что на короткой дистанции выгода от этого подхода неоднозначна.

Очень упрощенно процесс обработки каждого источника следующий:

1. Получаем URL интересующей нас страницы по её номеру используя метод `pagePath`. Например, `http://debeste.de/123`.
1. Делаем запрос по полученному из предыдущего пункта адресу, получаем содержимое страницы и отправляем в метод `parsePage`.
Дело в том, что каждый источник очень специфичен и некоторые данные доступны только на этом этапе, а некоторые станут 
доступны на следующем. Например, в случае с `Funpot`, на этом этапе доступна дата публикации мема, а на самой странице
мема эта информация отсутствует. Притом URL до самого ресурса (файл картинки или видео) станет известен лишь на 
персональной странице мема. Поэтому на этом этапе грабим всю доступную информацию, на следующем этапе будем её дополнять.
Тем не менее, ключевым (обязательным) к заполнению является поле `pageUrl` (путь до индивидуальной страницы мема).
1. Делаем запрос по полученному из предыдущего пункта `pageUrl` и грабим недостающую информацию. 
Ключевым на этом этапе часто является путь до самого файла мема (картинка, гифка, видео).
1. Профит. На этом этапе у нас наиболее полная информация о меме, которую можно было сграбить и путь до самого ресурса.
